ğŸŒŸ Full Workflow of the Project (From Start to End)

This is exactly what happens inside Spring when your project runs.

1ï¸âƒ£ Your Project Starts With Main Class
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);


This line does 4 Major Things Automatically:

âœ” Loads AppConfig
âœ” Scans all classes in com.ct package
âœ” Creates objects (@Component classes)
âœ” Injects dependencies (@Autowired)
2ï¸âƒ£ Spring Reads AppConfig
@Configuration
@ComponentScan("com.ct")
public class AppConfig {}


This tells Spring:

"Scan com.ct package and find classes with @Component."

So Spring searches in folders:

com.ct.car
com.ct.engine
com.ct.config
...

3ï¸âƒ£ Spring Finds Components and Creates Beans

It finds these:

âœ” Car
âœ” PetrolEngine
âœ” DieselEngine

Since they all have:

@Component


Spring creates objects (beans) for each.

So memory looks like:

PetrolEngine object created
DieselEngine object created
Car object created (waiting for Engine)

4ï¸âƒ£ Spring Looks at Car Constructor

Your Car class has:

public Car(Engine engine) { }


This means:

â€œCar needs an Engine object.â€

Spring tries to inject Engine.

But problem:

There are 2 engines:

petrolEngine

dieselEngine

So Spring becomes confused ğŸ˜µâ€ğŸ’« and throws:

âŒ NoUniqueBeanDefinitionException

Because it doesnâ€™t know which Engine Car wants.

5ï¸âƒ£ You Fix Ambiguity Using @Qualifier
public Car(@Qualifier("dieselEngine") Engine engine) {
    this.engine = engine;
}


Now Spring knows:

â€œCar must use dieselEngine.â€

So it injects that engine into Car.

Workflow:

Car needs Engine
â†’ Use Qualifier
â†’ Select dieselEngine
â†’ Inject dieselEngine into Car


Car object is now fully ready.

6ï¸âƒ£ Bean is Ready & Dependency Injection is Complete

Now memory looks like:

Car ---> DieselEngine

7ï¸âƒ£ MainApp Gets Car Bean
Car c = context.getBean(Car.class);


This gives you the Car object with the correct Engine.

Calling:

c.startCar();


Outputs:

Diesel engine started...
Car is running...

ğŸ”¥ COMPLETE WORKFLOW DIAGRAM
MainApp
  â†“
AppConfig
  â†“
@ComponentScan("com.ct")
  â†“
Spring finds Components:
    - Car
    - PetrolEngine
    - DieselEngine
  â†“
Spring creates engine beans
  â†“
Car needs Engine â†’ @Autowired
  â†“
Multiple engines found â†’ confusion
  â†“
@Qualifier("dieselEngine")
  â†“
Spring injects DieselEngine into Car
  â†“
Car object ready
  â†“
MainApp gets Car bean and runs it

âœ” YOUR UNDERSTANDING SHOULD NOW BE CLEAR
You learned:

How Spring scans components

How beans are created

How DI works

How @Autowired works

Why error occurred

How @Qualifier solved it

How the whole workflow executes