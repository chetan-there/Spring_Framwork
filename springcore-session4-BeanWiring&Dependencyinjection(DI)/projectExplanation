ğŸš— PROJECT OVERVIEW (Simplest Explanation)

You created a Car project that has:

A Car

Two types of engines: PetrolEngine and DieselEngine

An Engine interface (parent type)

A Spring container (IoC container)

The main goal of this project is:

ğŸ‘‰ To understand Dependency Injection (DI) and Loose Coupling

ğŸ¯ THE PROBLEM THIS PROJECT SOLVES

Normally, Java creates objects like this:

Engine e = new PetrolEngine();
Car car = new Car(e);


This is manual wiring â†’ The car is tightly coupled to PetrolEngine.

If tomorrow you want DieselEngine, you must change the code.

âŒ Not good
âŒ Not scalable
âŒ Not flexible

ğŸ‰ WHAT SPRING DOES IN THIS PROJECT

Springâ€™s IoC container:

âœ”ï¸ Creates objects for you
âœ”ï¸ Stores them
âœ”ï¸ Injects them into other objects
âœ”ï¸ Automatically picks the correct engine
âœ”ï¸ Removes tight coupling

This is called:

â­ IoC â€” Inversion of Control
â­ DI â€” Dependency Injection
ğŸ§± PROJECT COMPONENTS
1ï¸âƒ£ Engine Interface (Parent)
public interface Engine {
    void start();
}


This allows loose coupling because Car depends on an interface â€” NOT a concrete class.

2ï¸âƒ£ PetrolEngine Class
@Component
public class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol Engine Starting...");
    }
}

3ï¸âƒ£ DieselEngine Class
@Component
public class DieselEngine implements Engine {
    public void start() {
        System.out.println("Diesel Engine Starting...");
    }
}

4ï¸âƒ£ Car Class
@Component
public class Car {

    private Engine engine;

    @Autowired
    public Car(@Qualifier("petrolEngine") Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving...");
    }
}


Key points:

âœ”ï¸ Car does NOT create engine object
âœ”ï¸ Car receives engine from Spring (DI)
âœ”ï¸ Using @Qualifier, you choose WHICH engine

5ï¸âƒ£ AppConfig
@Configuration
@ComponentScan(basePackages = "com.ct")
public class AppConfig {
}


This tells Spring to automatically find all @Component classes.

6ï¸âƒ£ MainApp
public class MainApp {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(AppConfig.class);

        Car car = context.getBean(Car.class);
        car.drive();

        context.close();
    }
}

ğŸ›  HOW THE PROJECT RUNS (Step-by-step Flow)
STEP 1: Spring Container Starts
new AnnotationConfigApplicationContext(AppConfig.class)


Spring scans all classes inside com.ct.

STEP 2: Spring creates beans

Spring sees @Component â†’ creates object (bean)

Creates:

PetrolEngine bean

DieselEngine bean

Car bean

STEP 3: Spring looks at Carâ€™s constructor
@Autowired
public Car(@Qualifier("petrolEngine") Engine engine)


Spring says:

Car needs an Engine

There are 2 engines: petrol, diesel

@Qualifier tells Spring: â€œUse petrolEngineâ€

Spring injects PetrolEngine object into Car

STEP 4: MainApp asks Spring for Car
Car c = context.getBean(Car.class);


Now Car already has PetrolEngine inside it.

STEP 5: Car drives
Petrol Engine Starting...
Car is moving...

ğŸš¦ WHY YOU GET NoUniqueBeanDefinitionException

Because without @Qualifier, Spring sees:

Two beans of type Engine
â†’ petrolEngine
â†’ dieselEngine

Spring becomes confused:

ğŸ“¢ â€œWhich one should I use?â€

â†’ So it throws an error.

ğŸ§© Tight Coupling vs Loose Coupling in Your Project
Type	Example	Good/Bad	Reason
Tight Coupling	new PetrolEngine() inside Car	âŒ Bad	Car depends on specific engine
Loose Coupling	Car depends on Engine interface + DI	âœ”ï¸ Good	Engine can be swapped anytime