ğŸ• ZOMATO MINI PROJECT â€“ FULL EXPLANATION + WORKFLOW
ğŸ“ Your Project Structure
com.zomato
    â””â”€â”€ MainApp.java

com.zomato.service
    â”œâ”€â”€ OrderService.java
    â”œâ”€â”€ DeliveryService.java
    â””â”€â”€ ...
    
com.zomato.payment
    â”œâ”€â”€ PaymentStrategy.java   (interface)
    â”œâ”€â”€ UpiPayment.java
    â”œâ”€â”€ CardPayment.java
    â”œâ”€â”€ WalletPayment.java

com.zomato.config
    â””â”€â”€ AppConfig.java

ğŸ¯ What This Project Demonstrates

This Zomato mini-project teaches:

âœ” Strategy Design Pattern

â†’ dynamic behaviour change at runtime
(you can switch payment method any time)

âœ” Loose Coupling Using Interfaces

OrderService depends on PaymentStrategy (interface)
NOT on CardPayment, UpiPayment, etc.

âœ” Spring Core Concepts

@Component â†’ Bean creation

@Autowired â†’ Dependency Injection

Constructor Injection

Setter Injection

@Qualifier â†’ choose specific bean

AnnotationConfigApplicationContext â†’ start Spring

âœ” User Input + Dynamic Behavior

User chooses payment method using console.

ğŸ§  Simple Explanation 

Imagine Zomato.

You want to place an order.

You can pay using:

UPI

Card

Wallet

Each payment method has its own rules, but they all do one thing â†’ process payment.

So we create:

PaymentStrategy (interface)

ğŸ’¬ â€œWhatever the payment method is, it must have a pay() function.â€

UPI, Card, Wallet classes

They follow the same rule:

pay(amount)

ğŸš— OrderService â€“ The Main Brain

OrderService doesnâ€™t know how the payment works.

It only knows:

â€œI need SOME payment method that has a pay() method.â€

This makes the class super flexible.

We give the object from outside (setter injection) based on what the user chooses.

âš™ï¸ Workflow (Step-By-Step)
1ï¸âƒ£ Spring starts

AnnotationConfigApplicationContext(AppConfig.class)
â†’ Spring scans all packages
â†’ Creates objects (@Component beans)

Beans created automatically:

DeliveryService

UpiPayment

CardPayment

WalletPayment

OrderService

2ï¸âƒ£ User selects payment method

Console asks:

1. UPI
2. Card
3. Wallet


You enter: 2

3ï¸âƒ£ MainApp picks correct Spring Bean
strategy = context.getBean("cardPayment", PaymentStrategy.class);


Now strategy object = CardPayment.

4ï¸âƒ£ Setter injection updates OrderService
orderService.setPaymentStrategy(strategy);


Now OrderService is using: Card Payment

5ï¸âƒ£ OrderService.placeOrder() called
Order placed!
Payment Done using CardPayment!
Delivery Agent assigned...

ğŸ¯ In One Line: Workflow Summary

Spring loads â†’ user chooses payment â†’ Spring gives the correct strategy â†’ OrderService uses it â†’ delivery assigned.

ğŸ“Œ Why Loose Coupling Is Achieved?

Because OrderService does NOT depend on:

âŒ new CardPayment()
âŒ new UpiPayment()
âŒ new WalletPayment()

It depends on:

âœ” PaymentStrategy interface

So we can:

Add New Payment Method (PayPal, Crypto, COD)

Remove any method

Modify any method

WITHOUT changing OrderService code.

This is the superpower of Strategy Pattern.

ğŸ“Œ Why We Used Setter Injection?

Because payment can change anytime during runtime.

Example:

User first chooses UPI

Wishes to switch to Card
â†’ Setter injection allows this.

Constructor injection is used for things that never change.
Setter is used for things that can change.

ğŸ‰ Final Explanation in One Sentence

Your Zomato app uses Strategy Pattern + Spring DI to dynamically change payment methods at runtime while keeping the OrderService loosely coupled and flexible.