1ï¸ Concept: IoC Container (Inversion of Control)

Spring creates and manages objects instead of you manually using new.

ğŸ”¹ Code (MainApp.java):
ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);

Car car = context.getBean(Car.class);
car.d_drive();
car.p_drive();

ğŸ” Explanation

ApplicationContext â†’ Spring IoC Container

AnnotationConfigApplicationContext(AppConfig.class)

Loads configuration from AppConfig class

Creates all beans (DieselEngine, PetrolEngine, Car)

context.getBean(Car.class)

Spring returns a ready Car object

Constructor injection already done

You never write:

new Car(new DieselEngine(), new PetrolEngine());


Spring creates everything for you.

ğŸ¯ What You Learned

âœ” Spring creates all objects for you
âœ” You donâ€™t call constructors manually
âœ” You simply â€œaskâ€ the container to give you the ready object

2ï¸ Concept: @Configuration + @Bean (Java-based Spring Configuration)
ğŸ”¹ Code (AppConfig.java):
@Configuration
@ComponentScan(basePackages = "com.ct")
public class AppConfig {

    @Bean
    public DieselEngine dieselengine() {
        return new DieselEngine();
    }

    @Bean
    public PetrolEngine petrolengine() {
        return new PetrolEngine();
    }
}

ğŸ” Explanation

@Configuration

This class contains bean definitions

@Bean

Tells Spring: create an object of this class and manage it

Returned object becomes a Spring Bean

@ComponentScan("com.ct")

Tells Spring to find classes with @Component

Automatically creates beans for them (i.e., Car class)

ğŸ¯ What You Learned

âœ” Java-based bean configuration
âœ” How @Bean creates objects
âœ” How Spring scans components automatically
âœ” How Spring knows which classes to make beans

3ï¸ Concept: @Component (Spring-managed class)
ğŸ”¹ Code (Car.java):
@Component
public class Car {

    private DieselEngine d_engine;
    private PetrolEngine p_engine;

    public Car(DieselEngine d_engine, PetrolEngine p_engine) {
        this.d_engine = d_engine;
        this.p_engine = p_engine;
    }

    public void d_drive() {
        System.out.println(d_engine.start());
        System.out.println("Car is running ");
    }

    public void p_drive() {
        System.out.println(p_engine.start());
        System.out.println("Car is running ");
    }
}

ğŸ” Explanation

@Component

Marks Car as a Spring Bean

Automatically detected because of @ComponentScan

Constructor Injection

Spring sees Car requires DieselEngine and PetrolEngine

It finds those beans (@Bean in AppConfig)

It automatically passes them into the constructor

This is called Dependency Injection

Example:
Spring internally does this:

Car car = new Car(dieselEngineBean, petrolEngineBean);

ğŸ¯ What You Learned

âœ” Constructor-based dependency injection
âœ” Why @Component makes class auto-managed
âœ” How multiple engines are injected into Car
âœ” Loose coupling â€” Car does not create its own engine objects

4ï¸ Concept: Simple Bean Classes
ğŸ”¹ PetrolEngine.java
public class PetrolEngine {
    public String start() {
        return "petrol engine started....";
    }
}

ğŸ”¹ DieselEngine.java
public class DieselEngine {
    public String start() {
        return "diesel engine started...";
    }
}

ğŸ” Explanation

Plain Java classes (POJO)

No Spring annotations

Made into beans inside @Bean configuration

Called by the Car class

ğŸ¯ What You Learned

âœ” POJO classes can become Spring Beans
âœ” Spring supports both:

@Bean based configuration

@Component based configuration

ğŸ”¥ Full Project Learning Summary (Session 1)
âœ” IoC Container

Spring manages objects, not you.

âœ” Dependency Injection

Objects are passed into other objects automatically.

âœ” @Bean + @Configuration

Manual bean creation using Java.

âœ” @Component

Auto-detection of classes.

âœ” Constructor Injection

Best practice in real industry applications.

âœ” Loose Coupling

Car does not know how DieselEngine is created.